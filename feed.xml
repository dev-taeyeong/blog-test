<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://dev-taeyeong.github.io/</id><title>Develog</title><subtitle>hi</subtitle> <updated>2023-01-29T17:07:45+09:00</updated> <author> <name>TaeYeongJeong</name> <uri>https://dev-taeyeong.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://dev-taeyeong.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://dev-taeyeong.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2023 TaeYeongJeong </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>JWT</title><link href="https://dev-taeyeong.github.io/posts/jwt/" rel="alternate" type="text/html" title="JWT" /><published>2022-09-12T17:36:50+09:00</published> <updated>2023-01-29T17:04:23+09:00</updated> <id>https://dev-taeyeong.github.io/posts/jwt/</id> <content src="https://dev-taeyeong.github.io/posts/jwt/" /> <author> <name>taeyeong</name> </author> <category term="Spring" /> <summary> JWT(JSON Web Token)은 정보를 JSON 형태로 안전하게 전송하기 위한 토큰이다. JWT는 URL로 이용할 수 있는 문자열로만 구성되어 있으며, 디지철 서명이 적용되어 있어 신뢰할 수 있다. JWT는 주로 서버와의 통신에서 권한 인가를 위해 사용되는데, URL에서 사용할 수 있는 문자열로만 구성되어 있기 때문에 HTTP 구성요소 어디든 위치할 수 있다. JWT의 구조 JWT는 점(‘.’)으로 구분된 세 부분으로 구성된다. 헤더(Header) 내용(Payload) 서명(Signature) Header JWT의 Header는 검증과 관련된 내용을 담고 있다. 헤더는 alg와 typ 두 가지 정보를 포함한다. { "alg": "HS256", "t... </summary> </entry> <entry><title>RestTemplate 사용법과 커스텀 설정</title><link href="https://dev-taeyeong.github.io/posts/rest-template/" rel="alternate" type="text/html" title="RestTemplate 사용법과 커스텀 설정" /><published>2022-09-11T20:09:20+09:00</published> <updated>2022-09-12T17:30:55+09:00</updated> <id>https://dev-taeyeong.github.io/posts/rest-template/</id> <content src="https://dev-taeyeong.github.io/posts/rest-template/" /> <author> <name>taeyeong</name> </author> <category term="Spring" /> <summary> RestTemplate 동작 원리 Application에서 RestTemplate을 선언하고 URI와 HTTP 메서드, Header, Body 등을 설정한다. 외부 API로 요청을 보내게 되면 RestTemplate에서 HttpMessageConverter를 통해 RequestEntity를 요청 메시지로 변환한다. RestTemplate은 변환된 요청 메시지를 ClientHttpRequestFactory를 통해 ClientHttpRequest로 가져온 후 외부 API로 요청을 보낸다. 외부에서 요청에 대한 응답을 받으면 RestTemplate은 ResponseErrorHandler로 오류를 확인하고, 오류가 있다면 ClientHttpResponse에서 응답 데이터를 처리한다. 받은 응답 데... </summary> </entry> <entry><title>Logback</title><link href="https://dev-taeyeong.github.io/posts/logback/" rel="alternate" type="text/html" title="Logback" /><published>2022-09-10T21:19:00+09:00</published> <updated>2022-09-12T17:30:55+09:00</updated> <id>https://dev-taeyeong.github.io/posts/logback/</id> <content src="https://dev-taeyeong.github.io/posts/logback/" /> <author> <name>dev-taeyeong</name> </author> <category term="Spring" /> <summary> Logback은 log4j 이후에 출시된 로깅 프레임워크로 slf4j를 기반으로 구현됐으며, log4j에 비해 월등한 성능을 자랑한다. 또한 스프링 부트의 spring-boot-starter-web 라이브러리 내부에 내장되어 있어 별도의 의존성을 추가하지 않아도 사용할 수 있다. Logback의 특징 크게 5개의 로그 레벨(TRACE, DEBUG, INFO, WARN, ERROR)을 설정할 수 있다. ERROR: 로직 수행 중에 시스템이 심각한 문제가 발생해서 애플리케이션의 작동이 불가능한 경우를 의미 WRAN: 시스템 에러의 원인이 될 수 있는 경고 레벨을 의미 INFO: 애플리케이션의 상태 변경과 같은 정보 전달을 위해 사용 DEBUG... </summary> </entry> <entry><title>Spring Servlet Filter</title><link href="https://dev-taeyeong.github.io/posts/develog-220910/" rel="alternate" type="text/html" title="Spring Servlet Filter" /><published>2022-09-10T11:33:00+09:00</published> <updated>2022-09-10T11:33:00+09:00</updated> <id>https://dev-taeyeong.github.io/posts/develog-220910/</id> <content src="https://dev-taeyeong.github.io/posts/develog-220910/" /> <author> <name>cotes</name> </author> <category term="Develog" /> <summary> hi Titles hi @Component class ExceptionHandlerFilter : Filter { override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) { try { filterChain.doFilter(request, response) } catch (e: Exception) { val errorResponse = ErrorResponse(e.error.code, e.error.message) response.status = HttpStatus.BAD_REQ... </summary> </entry> </feed>

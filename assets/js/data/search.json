[ { "title": "JWT", "url": "/posts/jwt/", "categories": "Spring", "tags": "Spring, JWT", "date": "2022-09-12 17:36:50 +0900", "snippet": "JWT(JSON Web Token)은 정보를 JSON 형태로 안전하게 전송하기 위한 토큰이다.JWT는 URL로 이용할 수 있는 문자열로만 구성되어 있으며, 디지철 서명이 적용되어 있어 신뢰할 수 있다.JWT는 주로 서버와의 통신에서 권한 인가를 위해 사용되는데, URL에서 사용할 수 있는 문자열로만 구성되어 있기 때문에 HTTP 구성요소 어디든 위치할 수 있다.JWT의 구조JWT는 점(‘.’)으로 구분된 세 부분으로 구성된다. 헤더(Header) 내용(Payload) 서명(Signature)HeaderJWT의 Header는 검증과 관련된 내용을 담고 있다. 헤더는 alg와 typ 두 가지 정보를 포함한다.{ \"alg\": \"HS256\", \"typ\": \"JWT\"}alg 속성은 해싱 알고리즘을 지정한다. 해싱 알고리즘은 보통 SHA256 또는 RSA를 사용하며, 토큰을 검증할 때 사용되는 서명 부분에서 사용된다.HS256은 HMAC-SHA256 알고리즘을 사용한다는 의미이다. typ 속성에는 토큰의 타입을 지정한다.PayloadJWT의 Payload는 토큰에 담는 정보를 포함한다. 이곳에 포함된 속성들은 클레임(Claim)이라고 하며, 크게 세 가지로 분류된다. 등록된 클레임(Registered Claims) 공개 클레임(Public Claims) 비공개 클레임(Private Claims)등록된 클레임은 필수는 아니지만 토큰에 대한 정보를 담기 위해 이미 이름이 정해져 있는 클레임을 뜻한다.등록된 클레임들의 목록은 다음과 같다. iss: JWT의 발급자(Issuer) 주체를 나타낸다. iss의 값은 문자열이나 URI를 포함하는 대소문자를 구분하는 문자열이다. sub: JWT의 제목(Subject)이다. aud: JWT의 수신인(Audience)이다. JWT를 처리하려는 각 주체는 해당 값으로 자신을 식별해야 한다. 요청을 처리하는 주체가 ‘aud’ 값으로 자신을 식별하지 않으면 JWT는 거부된다. exp: JWT의 만료시간(Expiration)이다. 시간은 NumericDate 형식으로 지정해야 한다. nbf: ‘Not Before’를 의미한다. iat: JWT가 발급된 시간(Issued at)이다. jti: JWT의 식별자(JWT ID)이다. 주로 중복 처리를 방지하기 위해 사용된다.공개 클레임은 키 값을 마음대로 정의할 수 있다. 다만 충돌이 발생하지 않을 이름으로 설정해야 한다.비공개 클레임은 통신 간에 상호 합의되고 등록된 클레임과 공개 클레임이 아닌 클레임을 의미한다. 예시{ \"sub\": \"my jwt\", \"exp\": \"1662972970\", \"userId\": \"482fe84f-4d6e-41ce-b464-37a65b9bf7d7\", \"username\": \"taeyeong\"}SignatureJWT의 Signature는 인코딩된 헤더, 인코딩된 내용, 비밀키, 헤더의 알고리즘 속성값을 가져와 생성된다.예를 들어, HMAC-SHA256 알고리즘을 사용해서 서명을 생성한다면 다음과 같은 방식으로 생성된다.HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)JWT 생성해보기 JWT 공식 사이트Reference 스프링 부트 핵심 가이드 - 장정우 velopert 블로그 securitum" }, { "title": "RestTemplate 사용법과 커스텀 설정", "url": "/posts/rest-template/", "categories": "Spring", "tags": "Spring, RestTeamplate", "date": "2022-09-11 20:09:20 +0900", "snippet": "RestTemplate 동작 원리Application에서 RestTemplate을 선언하고 URI와 HTTP 메서드, Header, Body 등을 설정한다.외부 API로 요청을 보내게 되면 RestTemplate에서 HttpMessageConverter를 통해 RequestEntity를 요청 메시지로 변환한다.RestTemplate은 변환된 요청 메시지를 ClientHttpRequestFactory를 통해 ClientHttpRequest로 가져온 후 외부 API로 요청을 보낸다.외부에서 요청에 대한 응답을 받으면 RestTemplate은 ResponseErrorHandler로 오류를 확인하고, 오류가 있다면 ClientHttpResponse에서 응답 데이터를 처리한다.받은 응답 데이터가 정상적이라면 다시 한 번 HttpMessageConverter를 거쳐 자바 객체로 변환해서 애플리케이션으로 반환한다.RestTemplate의 대표적인 메서드 메서드 HTTP형태 설명 getForObject GET GET 형식으로 요청한 결과를 객체로 변환 getForEntity GET GET 형식으로 요청한 결과를 ResponseEntity 형식으로 반환 postForLocation POST POST 형식으로 요청한 결과를 헤더에 저장된 URI로 반환 postForObject POST POST 형식으로 요청한 결과를 객체로 반환 postForEntity POST POST 형식으로 요청한 결과를 ResponseEntity 형식으로 반환 delete DELETE DELETE 형식으로 요청 put PUT PUT 형식으로 요청 patchForObject PATCH PATCH 형식으로 요청한 결과를 객체로 반환 optionsForAllow OPTIONS 해당 URI에서 지원하는 HTTP 메서드를 조회 exchange any HTTP 헤더를 임의로 추가할 수 있고, 어떤 메서드 형식에서도 사용할 수 있음 execute any 요청과 응답에 대한 콜백을 수정 RestTemplate 사용하기getForEntity@Servicepublic class TestService { public UserDto getUser() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:8000\") .path(\"/api/v1/user\") .encode() .build() .toUri(); RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;UserDto&gt; responseEntity = restTemplate.getForEntity(uri, UserDto.class); return responseEntity.getBody(); }}아래와 같이 query parameter를 추가할 수도 있다.URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:8000\") .path(\"/api/v1/user\") .queryParam(\"name\", \"taeyeong\") .queryParam(\"age\", 20) .encode() .build() .toUri();expand() 메서드를 사용해서 path에 변수를 넣을 수 있다.URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:8000\") .path(\"/api/v1/user/{userId}\") .encode() .build() .expand(10) .toUri();값을 여러 개 넣어야 하는 경우는 콤마(,)로 구분해서 나열한다.URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:8000\") .path(\"/api/v1/user/{name}/{age}\") .encode() .build() .expand(\"taeyeong\", 20) .toUri();PostForEntity@Servicepublic class TestService { public UserResponse postUser() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:8000\") .path(\"/api/v1/user\") .encode() .build() .toUri(); UserRequest userRequest = new UserRequest(); userRequest.setName(\"taeyeong\"); userRequest.setAge(20); RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;UserResponse&gt; responseEntity = restTemplate.postForEntity(uri, userRequest, UserResponse.class); return responseEntity.getBody(); }}exchange@Servicepublic class TestService { public UserResponse exchangeUser() { URI uri = UriComponentsBuilder .fromUriString(\"http://localhost:8000\") .path(\"/api/v1/user\") .encode() .build() .toUri(); UserRequest userRequest = new UserRequest(); userRequest.setName(\"taeyeong\"); userRequest.setAge(20); RequestEntity&lt;UserRequest&gt; requestEntity = RequestEntity .post(uri) .header(\"my-header\", \"hi\") .body(userRequest); RestTemplate restTemplate = new RestTemplate(); ResponseEntity&lt;UserResponse&gt; responseEntity = restTemplate.exchange(requestEntity, UserResponse.class); return responseEntity.getBody(); }}RestTemplate 커스텀 설정RestTemplate은 HTTPClient를 추상화하고 있다.RestTemplate은 기본적으로 커넥션 풀을 지원하지 않는다. 이 기능을 지원하지 않으면 매번 호출할 때마다 포트를 열어 커넥션을 생성하게 되는데, TIME_WAIT 상태가 된 소켓을 다시 사용하려고 접근한다면 재사용하지 못하게 된다.이를 방지하기 위해 커넥션 풀 기능을 활성화해야 하는데, 대표적으로 아파치에서 제공하는 HttpClient로 대체해서 사용하는 방법이 있다. httpclient 의존성 추가implementation 'org.apache.httpcomponents:httpclient:4.5.13' 커스텀 RestTemplate 객체 생성 메서드 작성하기RestTemplate의 생성자에는 ClientHttpRequestFactory를 매개변수로 받는 생성자가 존재한다.public RestTemplate(ClientHttpRequestFactory requestFactory) { this(); this.setRequestFactory(requestFactory);}ClientHttpRequestFactory는 함수형 인터페이스로, 대표적인 구현체로는 SimpleClientHttpRequestFactory와 HttpComponentsClientHttpRequestFactory가 있다.별도의 구현체를 설정해서 전달하지 않으면 SimpleClientHttpRequestFactory를 사용한다.HttpComponentsClientHttpRequestFactory 객체를 생성해서 사용하면 RestTemplate의 Timeout을 설정할 수 있다.추가로 커넥션 풀을 설정하려면 HttpClient를 생성해 설정해주어야 하는데, HttpClient를 생성하는 방법에는 다음 두 가지가 있다. HttpClientBuilder.create() HttpClients.custom()public RestTemplate restTemplate() { HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(); // HttpClientBuilder.create() CloseableHttpClient client = HttpClientBuilder.create() .setMaxConnTotal(500) .setMaxConnPerRoute(500) .build(); // HttpClients.custom() CloseableHttpClient httpClient = HttpClients.custom() .setMaxConnTotal(500) .setMaxConnPerRoute(500) .build(); factory.setHttpClient(httpClient); factory.setConnectTimeout(3000); factory.setReadTimeout(5000); RestTemplate restTemplate = new RestTemplate(factory); return restTemplate;}생성한 HttpClient는 factory의 setHttpClient() 메서드를 통해 인자로 전달해서 설정할 수 있다.이렇게 설정된 factory 객체를 RestTemplate을 초기화 하는 과정에 인자로 전달하면 된다.Reference 스프링 부트 핵심 가이드 - 장정우" }, { "title": "Logback", "url": "/posts/logback/", "categories": "Spring", "tags": "Spring, logging, Logback", "date": "2022-09-10 21:19:00 +0900", "snippet": "Logback은 log4j 이후에 출시된 로깅 프레임워크로 slf4j를 기반으로 구현됐으며, log4j에 비해 월등한 성능을 자랑한다. 또한 스프링 부트의 spring-boot-starter-web 라이브러리 내부에 내장되어 있어 별도의 의존성을 추가하지 않아도 사용할 수 있다.Logback의 특징 크게 5개의 로그 레벨(TRACE, DEBUG, INFO, WARN, ERROR)을 설정할 수 있다. ERROR: 로직 수행 중에 시스템이 심각한 문제가 발생해서 애플리케이션의 작동이 불가능한 경우를 의미 WRAN: 시스템 에러의 원인이 될 수 있는 경고 레벨을 의미 INFO: 애플리케이션의 상태 변경과 같은 정보 전달을 위해 사용 DEBUG: 애플리케이션의 디버깅을 위한 메시지를 표시하는 레벨을 의미 TRACE: DEBUG 레벨보다 더 상세한 메시지를 표현하기 위한 레벨을 의미 실제 운영 환경과 개발 환경에서 각각 다른 출력 레벨을 설정해서 로그를 확인할 수 있다. Logback의 설정 파일을 일정 시간마다 스캔해서 애플리케이션을 재가동하지 않아도 설정을 변경할 수 있다. 별도의 프로그램 지원 없이도 자체적으로 로그 파일을 압축할 수 있다. 저장된 로그 파일에 대한 보관 기간 등을 설정해서 관리할 수 있다.Logback 설정 파일resources/logback-spring.xml&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;configuration&gt; &lt;!-- Property 영역 --&gt; &lt;property name=\"LOG_PATH\" value=\"./logs\"/&gt; &lt;!-- Appender 영역 --&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;!-- Encoder 영역 --&gt; &lt;encoder&gt; &lt;!-- Pattern 영역 --&gt; &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] [%thread] %logger %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"INFO_LOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;file&gt;${LOG_PATH}/info.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;${LOG_PATH}/info_${type}.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] [%thread] %logger %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- Root 영역 --&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;appender-ref ref=\"INFO_LOG\"/&gt; &lt;/root&gt;&lt;/configuration&gt;Appender 영역Appender 영역은 로그의 형태를 설정하고 어떤 방법으로 출력할지를 설정하는 곳이다. Appender 자체는 하나의 인터페이스를 의미하며, 하위에 여러 구현체가 존재한다. ConsoleAppender: 콘솔에 로그를 출력 FileAppender: 파일에 로그를 저장 RollingFileAppender: 여러 개의 파일을 순회하면서 로그를 저장 SMTPAppender: 메일로 로그를 전송 DBAppender: 데이터베이스에 로그를 저장appender 요소의 class 속성에 각 구현체를 정의한다. 그리고 하단에 filter 요소로 각 Appender가 어떤 레벨로 로그를 기록하는지 지정한다.&lt;appender name=\"INFO_LOG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;/filter&gt; &lt;file&gt;${LOG_PATH}/info.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;${LOG_PATH}/info_${type}.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] [%thread] %logger %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt;다음으로 encoder 요소를 통해 로그의 표현 형식을 패턴으로 정의한다.대표적인 패턴은 다음과 같다. 패턴 의미 %Logger{length} 로거의 이름 %-5leve 로그 레벨. -5는 출력 고정폭의 값 %msg(%message) 로그 메시지 %d 로그 기록 시간 %p 로깅 레벨 %F 로깅이 발생한 애플리케이션 파일명 %M 로깅이 발생한 메서드 이름 %I 로깅이 발생한 호출지의 정보 %thread 현재 스레드명 %t 로깅이 발생한 스레드명 %c 로깅이 발생한 카테고리 %C 로깅이 발생한 클래스명 %m 로그 메시지 %n 줄바꿈 %r 애플리케이션 실행 후 로깅이 발생한 시점까지의 시간 %L 로깅이 발생한 호출 지점의 라인 수 Root 영역설정 파일에 정의된 Appender를 활용하려면 Root 영역에서 Appender를 참조해서 로깅 레벨을 설정한다. 만약 특정 패키지에 대해 다른 로깅 레벨을 설정하고 싶다면 root 대신 logger를 사용한다.&lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;appender-ref ref=\"INFO_LOG\"/&gt;&lt;/root&gt;&lt;logger name=\"com.springboot.test\" level=\"DEBUG\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;appender-ref ref=\"INFO_LOG\"/&gt;&lt;/logger&gt;logger 요소의 name 속성에는 패키지 단위로 로깅이 적용될 범위를 지정하고, level 속성으로 로그 레벨을 지정한다. additivity 속성은 앞에서 지정한 패키지 범위에 하위 패키지를 포함할지 여부를 결정한다. 기본값은 true이며, 이 경우 하위 패키지를 모두 포함한다.Logback 적용Logback은 출력할 메시지를 Appender에게 전달할 Logger 객체를 각 클레스에 정의해서 사용한다.@RestController@RequestMapping(\"/log\")public class LogController { private final Logger LOGGER = LoggerFactory.getLogger(GetController.class); @GetMapping public String log() { LOGGER.info(\"log 메서드 호출\"); return \"log\"; }}[2022-09-10 22:02:54.492 [INFO ] [http-nio-8080-exec-8] com.springboot.api.TestController log 메서드 호출 로그를 통해 컨트롤러에 들어오는 값을 확인하기@GetMapping(\"/{variable}\")public String test( @PathVariable String variable) { LOGGER.info(\"variable: {}\", variable); return variable;}[2022-09-10 22:05:04.710 [INFO ] [http-nio-8080-exec-8] com.springboot.api.TestController variable: testReference 스프링 부트 핵심 가이드 - 장정우" }, { "title": "Spring Servlet Filter", "url": "/posts/develog-220910/", "categories": "Develog", "tags": "Develog, Spring, Kotlin, Servlet, Filter", "date": "2022-09-10 11:33:00 +0900", "snippet": "hiTitleshi@Componentclass ExceptionHandlerFilter : Filter { override fun doFilter(request: ServletRequest?, response: ServletResponse?, chain: FilterChain?) { try { filterChain.doFilter(request, response) } catch (e: Exception) { val errorResponse = ErrorResponse(e.error.code, e.error.message) response.status = HttpStatus.BAD_REQUEST.value() convertObjectToJson(errorResponse)?.let { s -&gt; response.writer.write(s) } } } private fun convertObjectToJson(o: Any?): String? { if (o == null) { return null } val mapper = ObjectMapper() return mapper.writeValueAsString(o) }}" } ]
